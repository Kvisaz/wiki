# Как быстро делать игры

Как можно больше четко прописанных планов.
Как можно больше кубиков, которые можно переиспользовать.
Как можно больше думатьь только по уникальной сути игры.

## Структура проекта

По подобию React

- src
  - index.ts - стартовый файл, который как-то запускает игру Phaser
  - pages - экраны игры, сборка всех компонентов вместе
  - components - базовые визуальные элементы, которые как кубики легко перетаскивать между проектами
  - store - общая логика всей игры. Что имеет смысл на всех экранах.
  - services - базовые логические невизуальные сервисы, тоже по идее кубики для быстрого переиспользования

### Pages

Экраны игры, в которой все компоненты собираются вместе и подключатся к общей логикой в store

Тут и толкьо тут меняются координаты статичных элементов. Это позволит сразу идти сюда и менять верстку.

### Сomponents

По идее - идеальные кубики, которые можно переиспользовать. Первая цель - именно переиспользовать. Поэтому они не привязывают к конкретной логике игры.

Поэтому в них будет какая-то своя логика. С этим придется жить.

При сборке экранов просто будем привязывать логику компонентов с общей логикой.

Действия пользователей обрабатывают чаще всего сами компоненты.

Пример

- герой. Реагирует на клавиши сразу, бегает по экрану.

### Store

Общая логика игры. Только то, что реально нужно делить между всеми или несколькими экранами. К примеру,

- score - нужно считать в экране боя и показывать в геймувер
- количество жизней
- валюта

Store можно воспринимать как общую базу данных. Желательно поддерживать минимальный размер такой базы.

### Services

Всякие логические помощники, скажем так. Счетчики score, работа с серверами, сохранялки сейвов, генераторы лабиринтов.

Общий принцип - универсальные штуки, которые как и компоненты, перетаскивают между играми.

# Todo

Расписать как рисовать компоненты.
Компонент - это класс по определенным принципам.

У него есть props / конфиг - это начальные данные. Используется при создании.

У него есть state - объект с логическими данными, которые меняются. State может не быть.

setState(newState) - метод, которым родитель или экран можеи изменить состояние компонента.

onStateChange() - метод, благодаря которому родитель или любое другое сущность может отслеживать изменения компонента

пример

```typescript
// где-то в экране или большом компоненте

const props = {
  health: 100,
  speed: 10,
  x: 0,
  y: 0,
};
this.hero = new Hero(props);
this.hero.onStateChange((newState, prevState) => {
  console.log("hero.speed", hero.speed);
  // передать в общую логику
  if (newState.speed != prevState.speed) {
    store.dispatch({ type: HERO_HEALTH_CHANGE, health: hero.health });
  }

  if (newState.x != prevState.x) {
    // проверить столкновение по X
  }

  if (newState.y != prevState.y) {
    // проверить столкновение по Y
  }
});
```

Почему это работает? При изменения своего state компонент всегда делает такое

```typescript
const prevState = this.state;
this.state = {
  ...prevState,
  speed: speed + 10,
};

this.subscribers.forEach((fn) => fn(prevState, this.state));
```
